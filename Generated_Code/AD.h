/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : AD.h
**     Project     : HC03_Project
**     Processor   : SKEAZ64MLH4
**     Component   : ADC_LDD
**     Version     : Component 01.183, Driver 01.00, CPU db: 3.00.000
**     Repository  : Kinetis
**     Compiler    : GNU C Compiler
**     Date/Time   : 2023-09-22, 10:04, # CodeGen: 0
**     Abstract    :
**         This device "ADC_LDD" implements an A/D converter,
**         its control methods and interrupt/event handling procedure.
**     Settings    :
**          Component name                                 : AD
**          A/D converter                                  : ADC
**          Discontinuous mode                             : no
**          Interrupt service/event                        : Enabled
**            A/D interrupt                                : INT_ADC0
**            A/D interrupt priority                       : medium priority
**            ISR Name                                     : AD_MeasurementCompleteInterrupt
**          A/D channel list                               : 10
**            Channel 0                                    : 
**              Channel mode                               : Single Ended
**                Input                                    : 
**                  A/D channel (pin)                      : PTC2/KBI0_P18/FTM2_CH2/ADC0_SE10
**            Channel 1                                    : 
**              Channel mode                               : Single Ended
**                Input                                    : 
**                  A/D channel (pin)                      : PTC1/KBI0_P17/FTM2_CH1/ADC0_SE9
**            Channel 2                                    : 
**              Channel mode                               : Single Ended
**                Input                                    : 
**                  A/D channel (pin)                      : PTC0/KBI0_P16/FTM2_CH0/ADC0_SE8
**            Channel 3                                    : 
**              Channel mode                               : Single Ended
**                Input                                    : 
**                  A/D channel (pin)                      : PTF7/KBI1_P15/ADC0_SE15
**            Channel 4                                    : 
**              Channel mode                               : Single Ended
**                Input                                    : 
**                  A/D channel (pin)                      : PTF6/KBI1_P14/ADC0_SE14
**            Channel 5                                    : 
**              Channel mode                               : Single Ended
**                Input                                    : 
**                  A/D channel (pin)                      : PTF5/KBI1_P13/ADC0_SE13
**            Channel 6                                    : 
**              Channel mode                               : Single Ended
**                Input                                    : 
**                  A/D channel (pin)                      : PTF4/KBI1_P12/ADC0_SE12
**            Channel 7                                    : 
**              Channel mode                               : Single Ended
**                Input                                    : 
**                  A/D channel (pin)                      : PTB3/KBI0_P11/SPI0_MOSI/FTM0_CH1/ADC0_SE7
**            Channel 8                                    : 
**              Channel mode                               : Single Ended
**                Input                                    : 
**                  A/D channel (pin)                      : PTB2/KBI0_P10/SPI0_SCK/FTM0_CH0/ADC0_SE6
**            Channel 9                                    : 
**              Channel mode                               : Single Ended
**                Input                                    : 
**                  A/D channel (pin)                      : PTA0/KBI0_P0/FTM0_CH0/I2C0_4WSCLOUT/ACMP0_IN0/ADC0_SE0
**          Static sample groups                           : Enabled
**            Sample group list                            : 3
**              Group 0                                    : 
**                Sample list                              : 2
**                  Sample 0                               : Enabled
**                    Channel index                        : 0
**                  Sample 1                               : Enabled
**                    Channel index                        : 9
**              Group 1                                    : 
**                Sample list                              : 4
**                  Sample 0                               : Enabled
**                    Channel index                        : 2
**                  Sample 1                               : Enabled
**                    Channel index                        : 4
**                  Sample 2                               : Enabled
**                    Channel index                        : 6
**                  Sample 3                               : Enabled
**                    Channel index                        : 8
**              Group 2                                    : 
**                Sample list                              : 4
**                  Sample 0                               : Enabled
**                    Channel index                        : 1
**                  Sample 1                               : Enabled
**                    Channel index                        : 3
**                  Sample 2                               : Enabled
**                    Channel index                        : 5
**                  Sample 3                               : Enabled
**                    Channel index                        : 7
**          Max. samples                                   : 8
**          A/D resolution                                 : 12 bits
**          Low-power mode                                 : Disabled
**          Sample time                                    : 3.5 clock periods
**          Conversion time                                : 4 ?s
**          ADC clock                                      : 5 MHz (200 ns)
**          Single conversion time - Single-ended          : 4.85 us
**          Single conversion time - Differential          : Differential mode not supported
**          Additional conversion time - Single-ended      : 4 us
**          Additional conversion time - Differential      : Differential mode not supported
**          Result type                                    : unsigned 16 bits, right justified
**          Trigger                                        : Disabled
**          Voltage reference                              : 
**            High voltage reference                       : 
**              Volt. ref. pin                             : VREFH/VDDA
**            Low voltage reference                        : 
**              Volt. ref. pin                             : VREFL
**          Initialization                                 : 
**            Enabled in init. code                        : yes
**            Auto initialization                          : no
**            Event mask                                   : 
**              OnMeasurementComplete                      : Enabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init                         - LDD_TDeviceData* AD_Init(LDD_TUserData *UserDataPtr);
**         Deinit                       - void AD_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         StartSingleMeasurement       - LDD_TError AD_StartSingleMeasurement(LDD_TDeviceData *DeviceDataPtr);
**         StartLoopMeasurement         - LDD_TError AD_StartLoopMeasurement(LDD_TDeviceData *DeviceDataPtr);
**         CancelMeasurement            - LDD_TError AD_CancelMeasurement(LDD_TDeviceData *DeviceDataPtr);
**         GetMeasuredValues            - LDD_TError AD_GetMeasuredValues(LDD_TDeviceData *DeviceDataPtr, LDD_TData...
**         SelectSampleGroup            - LDD_TError AD_SelectSampleGroup(LDD_TDeviceData *DeviceDataPtr, uint8_t...
**         CreateSampleGroup            - LDD_TError AD_CreateSampleGroup(LDD_TDeviceData *DeviceDataPtr,...
**         GetMeasurementCompleteStatus - bool AD_GetMeasurementCompleteStatus(LDD_TDeviceData *DeviceDataPtr);
**         SetOperationMode             - LDD_TError AD_SetOperationMode(LDD_TDeviceData *DeviceDataPtr,...
**
**     Copyright : 1997 - 2015 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file AD.h
** @version 01.00
** @brief
**         This device "ADC_LDD" implements an A/D converter,
**         its control methods and interrupt/event handling procedure.
*/         
/*!
**  @addtogroup AD_module AD module documentation
**  @{
*/         

#ifndef __AD_H
#define __AD_H

/* MODULE AD. */

/* Include shared modules, which are used for whole project */
#include "PE_Types.h"
#include "PE_Error.h"
#include "PE_Const.h"
#include "IO_Map.h"
/* Include inherited beans */

#include "IO_Map.h"
#include "Cpu.h"

#include "ADC_PDD.h"
#include "SIM_PDD.h"

#ifdef __cplusplus
extern "C" { 
#endif


/*! Peripheral base address of a device allocated by the component. This constant can be used directly in PDD macros. */
#define AD_PRPH_BASE_ADDRESS  0x4003B000U
  
/* Methods configuration constants - generated for all enabled component's methods */
#define AD_Init_METHOD_ENABLED         /*!< Init method of the component AD is enabled (generated) */
#define AD_Deinit_METHOD_ENABLED       /*!< Deinit method of the component AD is enabled (generated) */
#define AD_StartSingleMeasurement_METHOD_ENABLED /*!< StartSingleMeasurement method of the component AD is enabled (generated) */
#define AD_StartLoopMeasurement_METHOD_ENABLED /*!< StartLoopMeasurement method of the component AD is enabled (generated) */
#define AD_CancelMeasurement_METHOD_ENABLED /*!< CancelMeasurement method of the component AD is enabled (generated) */
#define AD_GetMeasuredValues_METHOD_ENABLED /*!< GetMeasuredValues method of the component AD is enabled (generated) */
#define AD_SelectSampleGroup_METHOD_ENABLED /*!< SelectSampleGroup method of the component AD is enabled (generated) */
#define AD_CreateSampleGroup_METHOD_ENABLED /*!< CreateSampleGroup method of the component AD is enabled (generated) */
#define AD_GetMeasurementCompleteStatus_METHOD_ENABLED /*!< GetMeasurementCompleteStatus method of the component AD is enabled (generated) */
#define AD_SetOperationMode_METHOD_ENABLED /*!< SetOperationMode method of the component AD is enabled (generated) */

/* Events configuration constants - generated for all enabled component's events */
#define AD_OnMeasurementComplete_EVENT_ENABLED /*!< OnMeasurementComplete event of the component AD is enabled (generated) */


/* Component specific public constants */

/* Driver mode */

/* A/D resolution of the component (the count of bits) */
#define AD_ADC_RESOLUTION               12

/* Name of AD channel. If the "A/D channel (pin) signal" property in the channel
   pin group is not empty the constant "ComponentName_Signal" with the value of the channel
   index is generated, where the ComponentName = value of the "Component name" property
   and "Signal" is the value of the " A/D channel (pin) signal" property. This constant
   can be used in the method CreateSampleGroup() to specify required channel.
   (See ComponentName_TSample struct) */

/* This constant contains the number of channels in the "A/D channel list"
   group */
#define AD_CHANNEL_COUNT                10u

/* This constant can be used in the sample array to create a gap in sample group.
   It is intended to disable a measurement of a sample */
#define AD_NO_CHANNEL                   0x1FU

/* This constant contains the number of static sample groups */
#define AD_STATIC_GROUP_COUNT           3U

/* These constants contain the number of samples in each static sample group. */
#define AD_STATIC_GROUP_0_SAMPLE_COUNT  2U
#define AD_STATIC_GROUP_1_SAMPLE_COUNT  4U
#define AD_STATIC_GROUP_2_SAMPLE_COUNT  4U

/* This constant contains the maximal size through all static sample groups */
#define AD_MAX_STATIC_GROUP_SAMPLE_COUNT 4U

/* HW specific public constants */

/* Maximal number of samples in one sample group. This constant is HW specific.
   The CreateSampleGroup() method returns ERR_PARAM_SAMPLE_COUNT if the SampleCount parameter
   is greater then this constant. The value of this constant depends on the number
   of samples the HW is capable to measure in one measurement cycle. */
#define AD_MAX_HW_SAMPLE_COUNT          8U

/* This constant informs about the actual width of results. */
#define AD_RESULT_WIDTH                 16U

/* This constant informs about the native size of result in bytes */
#define AD_RESULT_WIDTH_BYTES           2U

/* This parameter informs about the type of results. */
#define AD_RESULT_TYPE_UNSIGNED

/* Measurement result data type. Definition of the type depends
   on "Result type" property value. */
typedef uint16_t AD_TResultData;


/*
** ===================================================================
**     Method      :  AD_Init (component ADC_LDD)
*/
/*!
**     @brief
**         Initializes the device. Allocates memory for the device data
**         structure, allocates interrupt vectors and sets interrupt
**         priority, sets pin routing, sets timing, etc.
**         If the "Enable in init. code" is set to "yes" value then the
**         device is also enabled(see the description of the Enable()
**         method). In this case the Enable() method is not necessary
**         and needn't to be generated. 
**         This method can be called only once. Before the second call
**         of Init() the Deinit() must be called first.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Device data structure pointer.
*/
/* ===================================================================*/
LDD_TDeviceData* AD_Init(LDD_TUserData *UserDataPtr);

/*
** ===================================================================
**     Method      :  AD_Deinit (component ADC_LDD)
*/
/*!
**     @brief
**         Deinitializes the device. Switches off the device, frees the
**         device data structure memory, interrupts vectors, etc.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
*/
/* ===================================================================*/
void AD_Deinit(LDD_TDeviceData *DeviceDataPtr);

/*
** ===================================================================
**     Method      :  AD_StartSingleMeasurement (component ADC_LDD)
*/
/*!
**     @brief
**         This method starts one measurement of the selected group of
**         samples and exits immediately. This is ADC SW trigger method.
**         The group of samples for measurement is specified by
**         preceding call to [SelectSampleGroup()] or
**         [CreateSampleGroup] method. 
**         DMA disabled: The [OnMeasurementComplete() ] event is
**         invoked after the measurement is done and if the event is
**         enabled. Results of the measurement can be read by the
**         [GetMeasuredValues()] method. 
**         DMA enabled: DMA request from configured ADC is enabled
**         automatically. The [OnMeasurementComplete() ] event is
**         invoked after the requested number of results are
**         transferred to destination buffer by DMA and if the event is
**         enabled. [GetMeasuredValues()] method is not available if
**         DMA mode is enabled. If the DMA transfer was completed
**         before and DMA is not recofingured, DMA error can occur. See
**         also [SetBuffer()] method. 
**         The state of the measurement can be also polled by the
**         [GetMeasurementCompleteStatus()] method. The [Discontinuous
**         mode] doesn't support this method.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @return
**                         - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - The device doesn't work in the
**                           active clock configuration
**                           ERR_DISABLED - Component is disabled
**                           ERR_BUSY - A measurement is in progress 
*/
/* ===================================================================*/
LDD_TError AD_StartSingleMeasurement(LDD_TDeviceData *DeviceDataPtr);

/*
** ===================================================================
**     Method      :  AD_StartLoopMeasurement (component ADC_LDD)
*/
/*!
**     @brief
**         This method starts periodic measurement of the selected
**         group of and exits immediately. This is ADC SW trigger
**         method. The group of samples for measurement is specified by
**         preceding call to [SelectSampleGroup()] or
**         [CreateSampleGroup] method. 
**         DMA disabled: The [OnMeasurementComplete()] event is invoked
**         after the each measurement is done and the event is enabled.
**         Results of the measurement can be read by the
**         [GetMeasuredValues()] method. 
**         DMA enabled: DMA request from configured ADC is enabled
**         automatically. The [OnMeasurementComplete() ] event is
**         invoked after the requested number of results are
**         transferred to destination buffer by DMA and the event is
**         enabled. When DMA transfer is finished, DMA request is
**         automatically disabled by HW, but ADC loop mode is not
**         stopped. In order to start new loop measurement with DMA,
**         DMA must be reconfigured by [SetBuffer()] method.
**         [GetMeasuredValues()] method is not available if DMA mode is
**         enabled. 
**         The state of the measurement can be also polled by the
**         [GetMeasurementCompleteStatus()] method. This method is
**         available only if HW supports loop measurement. The
**         [Discontinuous mode] doesn't support this method.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @return
**                         - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - The device doesn't work in the
**                           active clock configuration
**                           ERR_DISABLED - Component is disabled
**                           ERR_BUSY - Measurement is in progress 
*/
/* ===================================================================*/
LDD_TError AD_StartLoopMeasurement(LDD_TDeviceData *DeviceDataPtr);

/*
** ===================================================================
**     Method      :  AD_CancelMeasurement (component ADC_LDD)
*/
/*!
**     @brief
**         This method cancels the measurement in progress. Typically
**         the OnMeasurementComplete() event is not invoked for
**         cancelled measurement. If DMA mode is enabled, DMA request
**         from ADC is disabled and DMA transfer is cancelled. 
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @return
**                         - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - The device doesn't work in the
**                           active clock configuration
**                           ERR_DISABLED - Component is disabled
*/
/* ===================================================================*/
LDD_TError AD_CancelMeasurement(LDD_TDeviceData *DeviceDataPtr);

/*
** ===================================================================
**     Method      :  AD_SelectSampleGroup (component ADC_LDD)
*/
/*!
**     @brief
**         This method selects one of the (design-time) predefined
**         [Static sample groups] for the next measurement. Each call
**         rewrites the preceding setting. Once any group is selected,
**         the measurement can be started multiple times. Note: This
**         method works only with the sample groups defined at design
**         time. For run-time defined groups use [CreateSampleGroup()]
**         method.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         GroupIndex      - Group index.
**     @return
**                         - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - The device doesn't work in the
**                           active clock configuration
**                           ERR_DISABLED - Component is disabled
**                           ERR_PARAM_GROUP - SampleGroup parameter
**                           value is out of range
**                           ERR_BUSY - Measurement is in progress 
*/
/* ===================================================================*/
LDD_TError AD_SelectSampleGroup(LDD_TDeviceData *DeviceDataPtr, uint8_t GroupIndex);

/*
** ===================================================================
**     Method      :  AD_CreateSampleGroup (component ADC_LDD)
*/
/*!
**     @brief
**         This method prepares HW for next measurement according to
**         array of samples defined during run-time. The array of
**         samples should be prepared prior to calling this method.
**         Pointer to the array is passed into this method in parameter
**         SampleGroupPtr. The number of samples is defined by
**         parameter SampleCount. Once any group is prepared, the
**         measurement can be started multiple times. Note: This method
**         works only with the sample groups defined during run-time.
**         For design-time defined groups use [SelectSampleGroup()]
**         method.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         SampleGroupPtr  - Pointer to the
**                           sample definition array. This array can be
**                           released as soon as the method ends.
**     @param
**         SampleCount     - Number of items in the
**                           sample definition array. Must be less than
**                           or equal to
**                           ComponentName_MAX_HW_SAMPLE_COUNT.
**     @return
**                         - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - The device doesn't work in the
**                           active clock configuration
**                           ERR_DISABLED - Component is disabled
**                           ERR_PARAM_INDEX - Channel index in
**                           SampleGroup structure is out of range
**                           ERR_PARAM_SAMPLE_COUNT - SampleCount
**                           variable value is out of range
**                           ERR_BUSY - Measurement is in progress 
*/
/* ===================================================================*/
LDD_TError AD_CreateSampleGroup(LDD_TDeviceData *DeviceDataPtr, LDD_ADC_TSample *SampleGroupPtr, uint8_t SampleCount);

/*
** ===================================================================
**     Method      :  AD_GetMeasuredValues (component ADC_LDD)
*/
/*!
**     @brief
**         This method copies results of the last measurement to the
**         user supplied buffer. Data size depends on the size of
**         measured sample group (see [SelectSampleGroup()] or
**         [CreateSampleGroup()] method). Data representation is
**         defined by the [Result type] property. Typically this method
**         is called from [OnMeasurementComplete] event to get results
**         of the last measurement. This method is not available if DMA
**         is enabled.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         BufferPtr       - Pointer to the start of the
**                           buffer for new results. Count of stored
**                           measured values equals to the count of the
**                           samples in the active sample group. It is
**                           in the user responsibility to provide
**                           buffer with appropriate size.
**     @return
**                         - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - The device doesn't work in the
**                           active clock configuration
**                           ERR_DISABLED - Component is disabled
*/
/* ===================================================================*/
LDD_TError AD_GetMeasuredValues(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr);

/*
** ===================================================================
**     Method      :  AD_GetMeasurementCompleteStatus (component ADC_LDD)
*/
/*!
**     @brief
**         Returns whether the measurement is done and the results can
**         be read by the user. It can be used to poll the state of
**         measurement if [Interrupt service/event] is disabled or if
**         [OnMeasurementComplete] event is disabled by the
**         [SetEventMask()] methods.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @return
**                         - Error code
**                           true - Measurement is done
**                           false - Measurement is in progress
*/
/* ===================================================================*/
bool AD_GetMeasurementCompleteStatus(LDD_TDeviceData *DeviceDataPtr);

/*
** ===================================================================
**     Method      :  AD_MeasurementCompleteInterrupt (component ADC_LDD)
**
**     Description :
**         Measurement complete interrupt handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
/* {Default RTOS Adapter} ISR function prototype */
PE_ISR(AD_MeasurementCompleteInterrupt);

/*
** ===================================================================
**     Method      :  AD_SetOperationMode (component ADC_LDD)
*/
/*!
**     @brief
**         This method requests to change the component's operation
**         mode. Upon a request to change the operation mode, the
**         component will finish a pending job first and then notify a
**         caller that an operation mode has been changed. When no job
**         is pending (ERR_OK), the component changes an operation mode
**         immediately and notifies a caller about this change. 
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by [Init] method.
**     @param
**         OperationMode   - Requested driver
**                           operation mode.
**     @param
**         ModeChangeCallback - Callback to
**                           notify the upper layer once a mode has been
**                           changed.
**     @param
**         ModeChangeCallbackParamPtr 
**                           - Pointer to callback parameter to notify
**                           the upper layer once a mode has been
**                           changed.
**     @return
**                         - Error code, possible codes: ERR_OK - The
**                           change operation mode request has been
**                           accepted, callback will notify an
**                           application as soon as the mode is changed.
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - This component is disabled
**                           by user. ERR_PARAM_MODE - Invalid operation
**                           mode. ERR_FAILED - Job is running and the
**                           driver can't cancel the job by itself (job
**                           has no implicit termination, explicit
**                           cancelation is needed). The driver has
**                           rejected the change operation mode request.
**                           This error is returned if continuous job is
**                           running. Such job can be started by
**                           [StartLoopMeasurement] or
**                           [StartLoopTriggeredMeasurement] method and
**                           it can be canceled by [CancelMeasurement]
**                           method. After the termination, this
**                           [SetOperationMode] method performs the
**                           operation mode change. ERR_BUSY - Job is
**                           running and the driver can't detect job end
**                           by itself. The end of the job can be
**                           detected by method [GetDriverState]. This
**                           error is returned if single job is running
**                           and [Interrupt service/event] is disabled.
**                           Such job can be started by
**                           [StartSingleMeasurement] method.
*/
/* ===================================================================*/
LDD_TError AD_SetOperationMode(LDD_TDeviceData *DeviceDataPtr, LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr);

/* END AD. */

#ifdef __cplusplus
}  /* extern "C" */
#endif 

#endif 
/* ifndef __AD_H */
/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.5 [05.21]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
